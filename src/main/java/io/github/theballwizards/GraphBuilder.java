package io.github.theballwizards;


import edu.princeton.cs.algs4.StdOut;
import edu.princeton.cs.algs4.SymbolDigraph;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/**
 * A Class To Help Build The Directed Symbol Graph
 *
 * Takes A Developer Defined Webscraper (Defined In Terms Of Settings) And Build The Symbol Graph
 * From Algs4 Using The Results Of The Webscraper. Once The Graph Has Been Created It Will Be Saved
 * In A Cached File, And That File Will Be Used Until The File Is Deleted Or The User Decides To Rebuild
 * The Graph File (Either Manually -- Not Highly Recommended, Or Programmatically By Calling `GraphBuilder.rebuild()`)
 *
 * Note: If Rebuilding Graph, The Developer Defined Webscraper Is Still Going To Be Used, So The Newly Created Cache File
 *       May Very Well Be The Same As The Old Cache File
 *
 * @author Bryson Crader
 */
public class GraphBuilder {
    public static final String GRAPH_FILEPATH = "src/main/resources/graph.txt";
    // Uses Default, Developer Provided Arguments, Consider Changing If The Need Arrises
    private static WebScraper webScraper = new WebScraper();

    /**
     * Builds a directional graph of urls from either web scraping or a saved cache file
     * @return A directional graph or urls
     */
    public static SymbolDigraph build() {
        if (hasCachedDataFile()) {
            // Here We Can Simply Read In The File
            return generateGraphFromCachedFile();
        } else {
            // Most Of The Functionality For Building A Graph Is Inside `rebuild`
            // The Only Difference Is We Make Sure That The Graph Cache Does Not Exist
            // Instead Of Creating A New Cache Each Time The Program Is Ran
            return rebuild();
        }
    }

    /**
     * Tells The Graph Builder That The Old Cached File Is No Longer Valid To Be
     * Reused And A New Graph And Cached Graph File Should Be Created And Used From
     * Here On Out.
     *
     * @return Returns The Newly Rebuilt Graph
     *
     * // TODO: Create Tests To Make Sure The Graph File Is Rebuilt Regardless Of The Cache's Existence Or Non-Existence
     */
    public static SymbolDigraph rebuild() {

        // First Create The Directories To The File
        String directoryPath = GRAPH_FILEPATH.substring(0, GRAPH_FILEPATH.lastIndexOf('/'));
        if (new File(directoryPath).mkdirs()) {
            System.err.println("Failed Creating Directories To Graph File");
        }

        // Then Create The Actual File
        try {
            File graphFile = new File(GRAPH_FILEPATH);
            if (!graphFile.createNewFile()) {
                System.err.println("Failed Creating Graph File");
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed Creating Graph File: " + e.getMessage());
        }

        // If The Cache File Does Not Exist, We Need To Create It
        // In Either Case, The File Will Be Empty, The Writer Does Not Truncate
        // So It Will Just Write All The Data As If The File Was Empty Beforehand
        try (FileWriter writer = new FileWriter(GRAPH_FILEPATH)) {
            String edgeList = webScraper.scrapeEdgeListOfUrls();

            writer.write(edgeList);

        } catch (IOException e) {
            System.err.printf("Failed Writing To Cached File Location '%s', Error: %s\n", GRAPH_FILEPATH, e);
        }
        return generateGraphFromCachedFile();
    }

    /**
     * Generates a directional graph of urls from an edge list.
     * Edge list should be generated by WebScraper.
     * @param edgeList Edge list of urls, separated by spaces and newlines.
     * @return A directional graph of urls.
     *
     * NOTE: This Function Should Be Deprecated Or Changed, The Constructor For SymbolDigraph Handles
     *       Reading Functionality Already. We Must Create The Cached File, Or Read From The Already Cached
     *       File, So In Either Case, We Would Read From The File Rather Than Pass The Edge List Directly.
     *
     *       In This Case, Im Going To Create A New Function, And We Can Handle Conflicts/Decision Later.
     *       Prefer `generateGraphFromCachedFile`
     *
     */
    @Deprecated
    private static SymbolDigraph generateGraphFromUrlsEdgeList(String edgeList) {
        return new SymbolDigraph(GRAPH_FILEPATH, " ");
    }

    /**
     * Reads In The Cached Graph File And Returns The Resulting Symbol Graph
     *
     * @return Returns The Resulting Symbol Graph Created From The Cached Graph File
     * @throws RuntimeException If Cached File Does Not Exist
     */
    private static SymbolDigraph generateGraphFromCachedFile() {
        if (!hasCachedDataFile())
            throw new RuntimeException("Cached File Does Not Exist, As Such, The Graph Cannot Be Created");
        return new SymbolDigraph(GRAPH_FILEPATH, " ");
    }

    /**
     * Checks if there is cached graph data and if it is valid.
     */
    private static boolean hasCachedDataFile() {
        File cachedFile = new File(GRAPH_FILEPATH);
        // If It Does Not Exist, Its Also Not A File, So Dont Bother Checking Both Conditions
        return cachedFile.isFile();
    }

    /**
     * Reads potentially saved graph data from the cache file.
     * Check with hasCachedDataFile before using.
     * @return An edge list of urls
     *
     * NOTE: This Function Should Be Deprecated, The Constructor For A SymbolDigraph
     *       Already Handles Reading Files, So We Only Need To Check If The File Actually
     *       Exists Before Reading.
     *
     */
    @Deprecated()
    private static String readGraphDataFromFile() {
        return null; //TODO
    }

    public static void main(String[] args) {
        StdOut.printf("Has File: %s\n", GraphBuilder.hasCachedDataFile() ? "True" : "False");
        var graph = GraphBuilder.build();
        StdOut.printf("Graph Is Built! Where Is X?\n");
        StdOut.printf("BlueJ: Index = %d\n", graph.indexOf("\"BlueJ\""));

    }

}
